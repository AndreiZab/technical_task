#### Алгоритм
Получаемые данные хранятся в векторе в виде периода(```dur```) с определнной средней(```avg```) 
(Например: с третей секунды, в течении 10 секунд, средняя скорость была 3 B/s)  
В следующей ячейке хранятся данные отличающтеся от предыдущих на некоторую велечину (задается с помощью ```PERCENT_DEVIATION```)  
При накомплении определнного количества данных находится средняя скорость и перекладываюся в одну ячейку другого вектора.
Всего таких вектора 3 (```small```, ```mid```, ```large```). При продолжительном измерении, максимально усредненные данные попадут в ```ultimate``` переменную.
  
#### Потери в точности  
1) Наибольшие потери в точности связанны с выбором минимального размера ячейки(одна секунда) для хранения данных
(Например: в середине третей секунды приходит ```GetAverageSpeed``` с запросом данных за последние две секунды.
Из-за минимальной размерности ячееки для хранения скорости,
будет посчитана данные только за вторую и третью секунды и не учтеные данные с середины первой по начало второй)  
Этого можно избежать уменьшив размерность ячеек и пожертвова памятью для хранения.
2) При приобразованиях uint32_t -> float. Этого можно избежать, начав хранить переменные во float, пожертвовав скоростью вычеслений. 
3) При усреднениях для оптимизации памяти. Выйграть в точности можно отказавшись от трех накопителей с разнным размером усреднения.

#### TODO
1) В данной реализации методы ```GetAverageSpeed``` и ```AddValue``` не рассчитаны на вызов одновеременно разными потоками. Добавлении примитивов синхронизации решает это проблему.
2) Что бы получить время - используется syscall ```time()```, что может замедлить работу и имеет потенциальную уязвимость 'Year 2038 problem' на 32-битной архитектуре

