#### Алгоритм
Получаемые данные хранятся в векторе в виде периода (```dur```) с определенной средней (```avg```) 
(Например: с третей секунды, в течении 10 секунд, средняя скорость была 3 B/s)  
В следующей ячейке хранятся данные, отличающиеся от предыдущих на некоторую величину (задается с помощью ```PERCENT_DEVIATION```)  
При накоплении определенного количества данных находится средняя скорость и перекладываются в одну ячейку другого вектора.
Всего таких вектора 3 (```small```, ```mid```, ```large```). При продолжительном измерении максимально усредненные данные попадут в ```ultimate``` переменную.
  
#### Потери в точности  
1) Наибольшие потери в точности связаны с выбором минимального размера ячейки (одна секунда) для хранения данных
(Например: в середине третей секунды приходит ```GetAverageSpeed``` с запросом данных за последние две секунды.
Из-за минимальной размерности ячеек для хранения скорости
будут посчитаны данные только за вторую и третью секунды и не учтены данные с середины первой по начало второй)  
Этого можно избежать, уменьшив размерность ячеек и пожертвовав памятью для хранения.
2) При вычислениях с преобразованиями float -> uint32_t. Этого можно избежать, начав хранить переменные во float, пожертвовав скоростью вычислений. 
3) При усреднениях для оптимизации памяти. Выйграть в точности можно, отказавшись от трех накопителей с разным размером усреднения и начав хранить все полученные данные.

#### TODO
1) В данной реализации методы ```GetAverageSpeed``` и ```AddValue``` не рассчитаны на вызов одновременно разными потоками. Добавление примитивов синхронизации решает это проблему.
2) Чтобы получить время используется syscall ```time()```, что может замедлить работу и имеет потенциальную уязвимость 'Year 2038 problem' на 32-битной архитектуре.

